# steps:

# 1 RGB2GRAY
# 2 threshold
# 3 angle of rotation
# 4 bounding rectangle ( 1 error check width, height, angle )

# 5  crop
# 6 check center of mass
# 7 check character width and height
# 8 check area

# 9 maybe check for 7 elements (bounding box, sign, 5 letters)


import cv2

frame = cv2.imread('Bosch_image.tif')

frame_s = cv2.resize(frame, None, fx=0.5, fy=0.5, interpolation=cv2.INTER_CUBIC)

# Create window first, then trackbar
cv2.namedWindow('Resized_image')
cv2.imshow('Resized_image', frame_s)

cv2.createTrackbar('T', 'Resized_image', 180, 255, lambda x: None)


#GRB 2 Gray
gray = cv2.cvtColor(frame_s, cv2.COLOR_BGR2GRAY)  #grayscale image


t = cv2.getTrackbarPos('T', 'Resized_image')
if t == 0:
    t = 180  # Higher threshold to reduce background noise
_, frame_t = cv2.threshold(gray, t, 255, cv2.THRESH_BINARY)
cv2.imshow('Binary', frame_t)  # Show binary image to see threshold effect

#find contours
contours, _ = cv2.findContours(frame_t, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
# concatenate all contours
import numpy as np
c = np.concatenate(contours)

# Get bounding box of all contours used for fitLine
fit_x, fit_y, fit_w, fit_h = cv2.boundingRect(c)
# Draw bounding box on which fitLine is based
cv2.rectangle(frame_s, (fit_x, fit_y), (fit_x + fit_w, fit_y + fit_h), (255, 0, 0), 2)

#Fit center line
rows, cols = gray.shape[:2]
[vx, vy, x, y] = cv2.fitLine(c, cv2.DIST_L2, 0, 0.01, 0.01)
T1 = int((-x[0] * vy[0] / vx[0]) + y[0])                         #left
T2 = int(((cols - x[0]) * vy[0] / vx[0]) + y[0])                 #right

import math as m
angle_rad = m.atan((T2 - T1) / cols)

angle_deg = angle_rad * 180.0 / m.pi
print('='*50)
print('TEXT ANGLE ANALYSIS')
print('='*50)
print(f'Angle in radians: {angle_rad:.4f}')
print(f'Angle in degrees: {angle_deg:.4f}')
print('='*50)
# Rotate to level the text
M = cv2.getRotationMatrix2D(((cols-1)/2.0, (rows-1)/2.0), angle_deg, 1)
frame_rot = cv2.warpAffine(gray, M, (cols, rows))

#cv2.imshow('Rotated_image', frame_rot)

frame_s = cv2.line(frame_s, (cols - 1, T2), (0, T1), (0, 255, 0), 2)

cv2.imshow('Line_image', frame_s)

# Find bounding rectangle
_, frame_t = cv2.threshold(frame_rot, t, 255, cv2.THRESH_BINARY)
contours, _ = cv2.findContours(frame_t, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
c = np.concatenate(contours)
br_x, br_y, br_w, br_h = cv2.boundingRect(c)

frame_crop = frame_rot[ br_y:br_y+br_h, br_x:br_x+br_w ]

# Draw bounding rectangle on the rotated image for visualization
frame_rot_vis = cv2.cvtColor(frame_rot, cv2.COLOR_GRAY2BGR)
cv2.rectangle(frame_rot_vis, (br_x, br_y), (br_x + br_w, br_y + br_h), (0, 255, 0), 2)
# cv2.imshow('Rotated with Bounding Box', frame_rot_vis)

# cv2.imshow('Cropped_image', frame_crop)



# Center of mass
def center_of_mass(cnt):
    M = cv2.moments(cnt)
    if M['m00'] == 0:
        return None  # Skip contours with zero area
    cX = int(M['m10'] / M['m00'])
    cY = int(M['m01'] / M['m00'])
    return cX, cY


_, frame_t = cv2.threshold(frame_crop, t, 255, cv2.THRESH_BINARY)
contours, _ = cv2.findContours(frame_t, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

# Create a color copy for visualization
frame_crop_color = cv2.cvtColor(frame_crop, cv2.COLOR_GRAY2BGR)

centers = []
for cnt in contours:
    result = center_of_mass(cnt)
    if result is None:
        continue  # Skip contours with zero area
    x, y = result
    bx, by, w, h = cv2.boundingRect(cnt)
    A = cv2.contourArea(cnt)
    
    # Filter out very small or very large contours (noise and outer boundary)
    if A < 50 or A > frame_crop.shape[0] * frame_crop.shape[1] * 0.5:
        continue
    
    centers.append([x, y, w, h, A])
    
    # Draw bounding box around each character
    cv2.rectangle(frame_crop_color, (bx, by), (bx + w, by + h), (0, 255, 0), 2)
    
    # Draw center of mass
    cv2.circle(frame_crop_color, (x, y), 3, (0, 0, 255), -1)
    
    # Display character number
    #cv2.putText(frame_crop_color, f"({x},{y})", (bx, by - 5), 
    #            cv2.FONT_HERSHEY_SIMPLEX, 0.3, (255, 0, 0), 1)
    cv2.putText(frame_crop_color, f"{len(centers)}", (bx, by - 5), 
                cv2.FONT_HERSHEY_SIMPLEX, 0.3, (255, 0, 0), 1)

print("Character centers (x, y, width, height, area):")
for i, c in enumerate(centers):
    print(f"  Character {i+1}: x={c[0]}, y={c[1]}, w={c[2]}, h={c[3]}, area={c[4]}")

cv2.imshow('Characters with Bounding Boxes', frame_crop_color)



with open("table.txt", "a") as f:
    for c in centers:
        f.write("%s\n" % c)

with open("table.txt", "r") as f:
    f.readlines()


table = []


def findError(table, cnt):
    tol = 0.05              #tolerance for error
    error_detected = 1
    for t in table:
        if cnt[0] < t[0]+tol*t[0] and cnt[0] > t[0]-tol*t[0]:                   #check x
            if cnt[1] < t[1]+tol*t[1] and cnt[1] > t[1]-tol*t[1]:               #check y
                if cnt[2] < t[2]+tol*t[2] and cnt[2] > t[2]-tol*t[2]:           #check width
                    if cnt[3] < t[3]+tol*t[3] and cnt[3] > t[3]-tol*t[3]:       #check height
                        if cnt[4] < t[4]+tol*t[4] and cnt[4] > t[4]-tol*t[4]:   #check area
                            error_detected = 0
                            break

cv2.waitKey()
cv2.destroyAllWindows()
